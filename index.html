<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WindUp Focus Timer</title>
    <!-- Load Inter font for clean, modern typography -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="stylesheet">
    <style>
        /* --- 1. CORE COLOR & SHADOW VARIABLES (Blue/Teal Theme) --- */
        :root {
            /* Accent Gradient (Blue/Teal) */
            --color-primary-start: #4CC9F0; /* Bright Teal */
            --color-primary-end: #4361EE;   /* Deep Blue */
            
            /* Background Colors */
            --color-bg-primary: #0B0B0B;    /* Deep Matte Black */
            --color-bg-secondary: #111111;  /* Card/UI Black */
            --color-drained-bg: #1A1A1A;    /* Faint matte grey for drained section */
            
            /* Text & Primary UI */
            --color-text-light: #E0E0E0;    
            --color-text-subtle: #666666;   
            
            /* Shadows & Glows (Soft, Realistic) */
            --shadow-inner: inset 0 2px 5px rgba(0, 0, 0, 0.6);
            --shadow-outer-soft: 0 6px 20px rgba(0, 0, 0, 0.7);
            /* Subtle accent glow for active elements */
            --glow-primary: 0 0 15px rgba(76, 201, 240, 0.4), 0 0 40px rgba(67, 97, 238, 0.2); 
        }

        /* --- 2. GLOBAL RESET & BASE STYLES --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            /* Smooth transitions for hover/focus states */
            transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94); 
        }

        body {
            background: var(--color-bg-primary);
            color: var(--color-text-light);
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; 
            transition: background-color 0.5s ease;
        }

        /* Utility class to center the content */
        .full-screen-center {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 50; 
        }

        /* --- 3. START PROMPT STYLES (Glassy Card) --- */
        #startPrompt {
            position: absolute; 
            z-index: 50;
            padding: 40px;
            border-radius: 28px; /* High radius for smoothness */
            background: var(--color-bg-secondary);
            border: 1px solid rgba(255, 255, 255, 0.05); /* Subtle light border */
            text-align: center;
            box-shadow: var(--shadow-outer-soft); 
            display: flex; 
            flex-direction: column;
            align-items: center;
            justify-content: center;
            max-width: 90%;
            min-width: 340px;
            transition: opacity 0.3s ease;
        }

        #startPrompt h1 {
            font-size: 32px;
            margin-bottom: 5px;
            color: var(--color-primary-start);
            font-weight: 700;
            text-shadow: 0 0 8px rgba(76, 201, 240, 0.5); /* Soft heading glow */
        }
        #startPrompt .subtitle {
            font-size: 14px;
            color: var(--color-text-subtle);
            margin-bottom: 25px;
            line-height: 1.4;
        }

        /* Time Input Styling */
        .time-inputs {
            display: flex;
            gap: 15px;
            margin-bottom: 40px;
        }
        .time-group label {
            font-size: 12px;
            margin-bottom: 8px;
            color: var(--color-text-subtle);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .time-input {
            width: 75px; 
            padding: 12px 0;
            font-size: 24px;
            font-weight: 600;
            text-align: center;
            background: var(--color-drained-bg);
            border: none;
            color: var(--color-text-light);
            border-radius: 12px; /* Smooth corners */
            box-shadow: var(--shadow-inner);
        }
        .time-input:focus {
            outline: none;
            border: 1px solid var(--color-primary-start);
            box-shadow: var(--shadow-inner), 0 0 10px rgba(76, 201, 240, 0.3);
        }
        /* Hide native spinner buttons */
        .time-input { -moz-appearance: textfield; }
        .time-input::-webkit-outer-spin-button,
        .time-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }

        /* Main Button (Soft Gradient + Subtle Lift) */
        .main-btn {
            padding: 16px 45px;
            background: linear-gradient(135deg, var(--color-primary-start), var(--color-primary-end));
            border: none;
            color: var(--color-bg-primary); /* Dark text on bright button */
            font-size: 18px;
            font-weight: 700;
            cursor: pointer;
            border-radius: 14px;
            box-shadow: 0 8px 30px rgba(67, 97, 238, 0.5); /* Stronger lift shadow */
            letter-spacing: 0.5px;
        }
        .main-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(67, 97, 238, 0.7);
        }
        .main-btn:active {
            transform: translateY(0);
            box-shadow: 0 4px 15px rgba(67, 97, 238, 0.4);
        }

        /* --- 4. GAME SCREEN & CONTROLS --- */
        #gameScreen {
            flex: 1;
            position: relative; 
            padding-bottom: 80px; 
        }

        /* Controls Section (Minimalist Top Bar) */
        .controls {
            padding: 15px 20px;
            display: flex;
            justify-content: center;
            gap: 15px;
            z-index: 10;
        }
        .mode-btn {
            padding: 8px 20px;
            background: var(--color-bg-secondary);
            border: 1px solid #222;
            color: var(--color-text-subtle);
            cursor: pointer;
            font-size: 14px;
            border-radius: 10px;
            box-shadow: var(--shadow-inner);
        }
        .mode-btn:hover {
            color: var(--color-text-light);
            border-color: #444;
        }
        .mode-btn.active {
            background: linear-gradient(135deg, var(--color-primary-start), var(--color-primary-end));
            color: var(--color-bg-primary); 
            border-color: var(--color-primary-end);
            font-weight: 600;
            box-shadow: var(--glow-primary); 
            transform: scale(1.03);
        }

        .timer-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative; 
            height: 100%;
        }

        /* Utility class to show the active timer */
        .active-mode { display: flex !important; }

        /* --- 5. VISUAL TIMER MODES --- */

        /* 5.1 Line Timer (Horizontal Bar) */
        .line-timer {
            width: 90%;
            max-width: 600px;
            height: 20px; 
            background: var(--color-drained-bg);
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #222; /* Thin outline */
            box-shadow: var(--shadow-inner), 0 5px 10px rgba(0, 0, 0, 0.4); /* Subtle matte shadow */
            display: none;
        }
        .line-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--color-primary-start), var(--color-primary-end));
            width: 100%;
            transition: width 0.1s linear;
        }

        /* 5.2 Square Timer (Shrinking Inward) */
        .square-timer {
            width: 250px; 
            height: 250px;
            background: var(--color-drained-bg);
            border: 1px solid #222;
            display: none;
            align-items: center;
            justify-content: center;
            border-radius: 22px; /* Specified rounded corners */
            box-shadow: var(--shadow-outer-soft);
        }
        .square-inner {
            background: linear-gradient(135deg, var(--color-primary-start), var(--color-primary-end));
            transition: all 0.1s linear;
            border-radius: 18px; 
            box-shadow: var(--glow-primary); /* Soft edge glow */
            /* Subtle depth effect by creating a slight inset */
            border: 2px solid rgba(255, 255, 255, 0.1); 
        }

        /* 5.3 Circle Timer (Radial) */
        .circle-timer {
            width: 340px; /* Larger for premium feel */
            height: 340px;
            position: relative;
            display: none;
            /* Allow touch events to target this area */
            touch-action: manipulation; 
        }
        .circle-bg {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: var(--color-drained-bg);
            border: 1px solid #222;
            position: relative;
            overflow: hidden;
            box-shadow: var(--shadow-outer-soft);
        }
        /* Hidden center glow element (volumetric glow) */
        .center-glow {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50%;
            height: 50%;
            border-radius: 50%;
            background: radial-gradient(circle at center, rgba(76, 201, 240, 0.3) 0%, rgba(67, 97, 238, 0) 70%);
            z-index: 2; /* Below the canvas but above the background */
            pointer-events: none;
            opacity: 0.8;
        }

        /* Canvas for pie chart (above the center glow) */
        #pieCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3; 
        }
        
        /* --- 6. PERSISTENT DISPLAY & POPUP --- */

        /* Fixed Footer Display (Minimalist and clean) */
        .timer-display {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            /* Glassy/Transparent effect */
            background: rgba(17, 17, 17, 0.7); 
            backdrop-filter: blur(8px);
            padding: 12px 30px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 14px;
            font-weight: 500;
            color: var(--color-text-light);
            z-index: 100;
            line-height: 1.5; 
            text-align: center;
            box-shadow: var(--shadow-outer-soft);
        }
        .display-focus-level {
            font-weight: 700;
            color: var(--color-primary-start);
            margin-bottom: 2px;
            letter-spacing: 0.5px;
        }
        .display-time-left {
            color: var(--color-text-light);
            font-size: 18px;
            font-weight: 600;
        }

        /* Popup (Distraction Alert) - Premium Style */
        .popup {
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            animation: fadeIn 0.3s ease;
        }
        .popup-content {
            background: var(--color-bg-secondary);
            padding: 40px 60px;
            border-radius: 28px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
            animation: scaleIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: var(--glow-primary); 
            max-width: 90%;
        }
        .popup h2 {
            font-size: 38px;
            color: var(--color-primary-start);
            margin-bottom: 15px;
            font-weight: 700;
        }
        .popup p {
            margin-bottom: 30px;
            font-size: 16px;
            color: var(--color-text-light);
        }
        .popup-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
        }
        .popup button {
            /* Inherit main-btn style for primary action */
            padding: 12px 30px;
            font-size: 16px;
        }
        .popup button.reset-btn {
            background: var(--color-drained-bg);
            color: var(--color-text-light);
            border: 1px solid #333;
            box-shadow: var(--shadow-inner);
            font-weight: 500;
        }
        .popup button.reset-btn:hover {
            background: #222;
            border-color: #444;
            transform: translateY(-1px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
        }

        /* --- 7. KEYFRAME ANIMATIONS --- */
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes scaleIn { 0% { transform: scale(0.7); opacity: 0; } 80% { transform: scale(1.05); opacity: 1; } 100% { transform: scale(1); } }
    </style>
</head>
<body>
    <!-- Game Screen (The main and only non-popup screen) -->
    <div id="gameScreen" style="flex: 1; flex-direction: column;">
        <div class="controls">
            <button class="mode-btn" data-mode="line" onclick="switchMode('line')">Line</button>
            <button class="mode-btn" data-mode="square" onclick="switchMode('square')">Square</button>
            <button class="mode-btn active" data-mode="circle" onclick="switchMode('circle')">Circle</button>
        </div>
    
        <div class="timer-container">
            <!-- Start Prompt (Only visible when isGameActive is false) -->
            <div id="startPrompt">
                <h1>WindUp Focus</h1>
                <p class="subtitle">A digital wind-up box to stop distractions. Set your goal, then hold to wind up your focus meter. Release, and it slowly unwinds.</p>
                
                <div class="time-inputs">
                    <div class="time-group">
                        <label for="hrsInput">HOURS</label>
                        <input type="number" id="hrsInput" class="time-input" value="00" min="0" max="99" onchange="calculateGoalTime()" step="1">
                    </div>
                    <div class="time-group">
                        <label for="minInput">MINUTES</label>
                        <input type="number" id="minInput" class="time-input" value="01" min="0" max="59" onchange="calculateGoalTime()" step="1">
                    </div>
                    <div class="time-group">
                        <label for="secInput">SECONDS</label>
                        <input type="number" id="secInput" class="time-input" value="00" min="0" max="59" onchange="calculateGoalTime()" step="1">
                    </div>
                </div>

                <button class="main-btn" onclick="startGame()">START FOCUS</button>
            </div>

            <!-- Line Mode -->
            <div class="line-timer" id="lineTimer">
                <div class="line-fill" id="lineFill"></div>
            </div>
    
            <!-- Square Mode -->
            <div class="square-timer" id="squareTimer">
                <div class="square-inner" id="squareInner"></div>
            </div>
    
            <!-- Circle Mode (Default active mode) -->
            <div class="circle-timer active-mode" id="circleTimer">
                <div class="circle-bg">
                    <!-- Subtle Volumetric Glow in the center -->
                    <div class="center-glow"></div>
                    <!-- Canvas is used for high-fidelity pie chart drawing -->
                    <canvas id="pieCanvas"></canvas>
                </div>
            </div>
        </div>
    
        <!-- Premium Fixed Footer Display -->
        <div class="timer-display" id="timerDisplay">
            <div class="display-focus-level" id="focusLevel">READY</div>
            <div class="display-time-left" id="timeLeft">00:00:00</div>
        </div>
    </div>

    <!-- Popup for Distraction Alert -->
    <div class="full-screen-center popup" id="popup" style="display: none;">
        <div class="popup-content">
            <h2>You got distracted!</h2>
            <p>Focus harder next time! Would you like to try again or reset?</p>
            <div class="popup-buttons">
                <!-- Buttons updated by JS based on success/failure -->
                <button class="main-btn" onclick="startGame()">Try Again</button>
                <button class="reset-btn" onclick="resetGameToReady()">Reset</button>
            </div>
        </div>
    </div>

    <script>
        // --- State Variables ---
        let timer = 100; // The core focus percentage (0-100) - Represents the Focus Meter
        let isHolding = false; // Tracks if the user is actively focused (holding mouse/touch)
        let currentMode = 'circle'; // Current visual mode
        let timerInterval = null; // Reference to the setInterval loop
        let hasPlayedSound = false; // Prevents sound from playing multiple times at 0%
        let isGameActive = false; // State to track if the timer loop is running

        // New State for Goal and Time Tracking
        let goalTimeSeconds = 60; // Total duration of the Focus Meter Drain Time
        let timeElapsed = 0; // Tracks the progress towards the goal (max goalTimeSeconds)
        let drainRate = 100 / (60 * 10); // Rate per 0.1s tick to drain fully in goalTimeSeconds (initialized for 60s)
        let grossRefillRate = 100 / 60; // Rate per 0.1s tick to refill fully in 10% of goalTimeSeconds (initialized for 60s)

        // --- State for Circle Smoothing ---
        let displayedTimer = 100; // The value currently being drawn (smoother than 'timer')
        let circleDrawLoop = null; // Reference to the requestAnimationFrame ID

        // --- DOM Elements ---
        const gameScreen = document.getElementById('gameScreen');
        const startPrompt = document.getElementById('startPrompt');
        const popup = document.getElementById('popup');
        
        // Time Input references
        const hrsInput = document.getElementById('hrsInput');
        const minInput = document.getElementById('minInput');
        const secInput = document.getElementById('secInput');

        // Display parts
        const focusLevelDisplay = document.getElementById('focusLevel');
        const timeLeftDisplay = document.getElementById('timeLeft');
        
        // --- Canvas Setup for Circle Mode ---
        const canvas = document.getElementById('pieCanvas');
        const ctx = canvas.getContext('2d');
        // Initialize canvasSize to the CSS size (340px) as a default fallback
        let canvasSize = 340; 

        // Define CSS variables for use in Canvas (needed for gradients)
        const PRIMARY_START = '#4CC9F0'; 
        const PRIMARY_END = '#4361EE';
        const DRAINED_BG = '#1A1A1A';


        /**
         * Sets up the canvas dimensions and handles high DPI scaling.
         */
        function setupCanvas() {
            const circleTimer = document.getElementById('circleTimer');
            if (circleTimer.offsetWidth < 10) {
                console.warn('Circle Timer element size too small to initialize canvas.');
                return; 
            }

            const dpr = window.devicePixelRatio || 1;
            canvasSize = circleTimer.offsetWidth;

            canvas.width = canvasSize * dpr;
            canvas.height = canvasSize * dpr;
            canvas.style.width = canvasSize + 'px';
            canvas.style.height = canvasSize + 'px';
            ctx.scale(dpr, dpr);
        }

        /**
         * Draws the pie chart fill using the Canvas API with soft, glossy effects.
         * @param {number} percentage The percentage (0-100) to display.
         */
        function drawPie(percentage) {
            if (!ctx || !canvas || canvasSize <= 10) return;

            // Clear the previous frame
            ctx.clearRect(0, 0, canvasSize, canvasSize);
                
            const centerX = canvasSize / 2;
            const centerY = canvasSize / 2;
            const radius = (canvasSize / 2) - 5; // Account for any potential border/shadow space

            if (radius <= 0) return;

            // 1. Draw the Drained Section (Dark Grey background)
            // This creates the "fade into dark grey" effect for the empty space
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.fillStyle = DRAINED_BG;
            ctx.fill();
            
            if (percentage > 0) {
                // 2. Draw the Active Fill Section (Gradient)
                // Start from the top (-Math.PI / 2) and go clockwise
                const startAngle = -Math.PI / 2;
                // Percentage is inverse for draining timer: 100% is full circle, 0% is empty
                const endAngle = (percentage / 100) * 2 * Math.PI + startAngle;
                    
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.closePath();
                    
                const gradient = ctx.createLinearGradient(0, 0, canvasSize, canvasSize);
                gradient.addColorStop(0, PRIMARY_START);
                gradient.addColorStop(1, PRIMARY_END);
                ctx.fillStyle = gradient;
                ctx.fill();

                // 3. Add Glossy Edge Ring/Inner Glow to the Fill (Subtle)
                ctx.globalAlpha = 0.4;
                ctx.shadowColor = PRIMARY_START;
                ctx.shadowBlur = 10;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                // Redraw a thin path to apply the shadow/glow to the edge
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius - 2, startAngle, endAngle);
                ctx.lineWidth = 1;
                ctx.strokeStyle = 'white'; 
                ctx.stroke();

                // Reset canvas shadows and transparency for the next frame
                ctx.globalAlpha = 1.0;
                ctx.shadowBlur = 0;
            } else {
                // If 0%, ensure no glow is left
                ctx.shadowBlur = 0;
            }
        }
        
        /**
         * Uses requestAnimationFrame to smoothly update the circle visualization.
         */
        function drawSmoothedCircle() {
            // Check if the game is active AND the current mode is circle before continuing
            if (!isGameActive || currentMode !== 'circle') {
                circleDrawLoop = null;
                return; 
            }

            // Interpolate the displayed value towards the actual timer value (smooth easing)
            const smoothingFactor = 0.15; 
            displayedTimer = displayedTimer + (timer - displayedTimer) * smoothingFactor;

            // Call the drawing function with the smoothed value
            drawPie(displayedTimer);

            // Request next frame
            circleDrawLoop = requestAnimationFrame(drawSmoothedCircle);
        }


        // --- Audio Context for Beep Sound (Simplified) ---
        let audioContext = null; 
        function getAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            return audioContext;
        }

        /**
         * Plays a short, attention-grabbing beep sound on distraction.
         */
        function playBeep() {
            if (hasPlayedSound) return;
            hasPlayedSound = true;

            const ac = getAudioContext();
            if (ac.state === 'suspended') { ac.resume(); }
            
            const oscillator = ac.createOscillator();
            const gainNode = ac.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(ac.destination);

            oscillator.frequency.value = 800;
            gainNode.gain.setValueAtTime(0.3, ac.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, ac.currentTime + 0.5);

            oscillator.start(ac.currentTime);
            oscillator.stop(ac.currentTime + 0.5);
        }

        // --- Utility Functions ---

        /**
         * Calculates the goal time from inputs and the corresponding focus rates.
         */
        window.calculateGoalTime = function() {
            const hrsValue = parseInt(hrsInput.value);
            const minValue = parseInt(minInput.value);
            const secValue = parseInt(secInput.value);

            const hrs = Math.min(99, Math.max(0, hrsValue || 0));
            const min = Math.min(59, Math.max(0, minValue || 0));
            const sec = Math.min(59, Math.max(0, secValue || 0));

            hrsInput.value = hrs.toString().padStart(2, '0');
            minInput.value = min.toString().padStart(2, '0');
            secInput.value = sec.toString().padStart(2, '0');

            const newGoalTime = (hrs * 3600) + (min * 60) + sec;
            
            goalTimeSeconds = Math.max(10, newGoalTime); 

            // --- RATE CALCULATIONS ---
            const totalTicks = goalTimeSeconds * 10;
            drainRate = 100 / totalTicks;
            grossRefillRate = 100 / goalTimeSeconds;
            // --- END RATE CALCULATIONS ---
            
            const remainingSec = goalTimeSeconds % 60;
            const totalMin = Math.floor(goalTimeSeconds / 60);
            const remainingMin = totalMin % 60;
            const totalHrs = Math.floor(totalMin / 60);

            // Update display values but only in the start prompt, not the footer display
            if (startPrompt.style.display !== 'none') {
                hrsInput.value = totalHrs.toString().padStart(2, '0');
                minInput.value = remainingMin.toString().padStart(2, '0');
                secInput.value = remainingSec.toString().padStart(2, '0');
            }
        }

        /**
         * Controls which screen is visible.
         * @param {'game' | 'popup'} screenName 
         */
        function setScreen(screenName) {
            popup.style.display = 'none';

            if (screenName === 'game') {
                gameScreen.style.display = 'flex';
            } else if (screenName === 'popup') {
                popup.style.display = 'flex';
            }
        }

        // --- Game Flow Functions ---

        function startGameInterval() {
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            isGameActive = true;
            timerInterval = setInterval(updateTimer, 100); 

            if (currentMode === 'circle' && !circleDrawLoop) {
                circleDrawLoop = requestAnimationFrame(drawSmoothedCircle);
            }
        }

        function stopGameInterval() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            isGameActive = false;

            if (circleDrawLoop) {
                cancelAnimationFrame(circleDrawLoop);
                circleDrawLoop = null;
            }
        }
        
        window.startGame = function() {
            calculateGoalTime(); 
            timer = 100; 
            displayedTimer = 100; 
            timeElapsed = 0; 
            hasPlayedSound = false;
            setScreen('game'); 
            startPrompt.style.display = 'none'; 
            updateDisplay();
            startGameInterval();
        }

        window.resetGameToReady = function() {
            stopGameInterval();
            timer = 100; 
            displayedTimer = 100; 
            timeElapsed = 0; 
            updateDisplay();
            setScreen('game'); 
            startPrompt.style.display = 'flex'; 
            
            focusLevelDisplay.innerHTML = 'READY';
            timeLeftDisplay.innerHTML = '00:00:00';

            if (currentMode === 'circle') {
                drawPie(100);
            }
        }

        function showGoalCompletedPopup() {
            stopGameInterval();
            
            document.querySelector('#popup h2').textContent = 'GOAL REACHED!';
            
            const finalHrs = Math.floor(goalTimeSeconds / 3600);
            const finalMins = Math.floor((goalTimeSeconds % 3600) / 60);
            const finalSecs = Math.floor(goalTimeSeconds % 60);
            const finalTimeDisplay = `${finalHrs.toString().padStart(2, '0')}:${finalMins.toString().padStart(2, '0')}:${finalSecs.toString().padStart(2, '0')}`;

            document.querySelector('#popup p').textContent = `You maintained focus for your goal of ${finalTimeDisplay}. Amazing work!`;
            
            document.querySelector('#popup button:first-child').textContent = 'Start New Timer';
            document.querySelector('#popup button:first-child').onclick = resetGameToReady;
            document.querySelector('#popup button.reset-btn').style.display = 'none';
            

            // Restore the background color to signal success (subtle green fade)
            document.body.style.backgroundColor = '#1C312E'; 
            setTimeout(() => { document.body.style.backgroundColor = '#0B0B0B'; }, 1000);

            setScreen('popup');
        }

        function showDistractedPopup() {
            stopGameInterval();
            
            document.querySelector('#popup h2').textContent = 'Focus Lost';
            document.querySelector('#popup p').textContent = 'Your Focus Meter drained out. Try winding up more often! Would you like to try again or reset?';
            document.querySelector('#popup button:first-child').textContent = 'Try Again';
            document.querySelector('#popup button:first-child').onclick = startGame;
            document.querySelector('#popup button.reset-btn').style.display = 'inline-block';

            // Flash background red on failure
            document.body.style.backgroundColor = '#300000'; 
            setTimeout(() => { document.body.style.backgroundColor = '#0B0B0B'; }, 500);

            setScreen('popup');
            playBeep();
        }

        function updateTimer() {
            if (!isGameActive) return;
            
            let netFocusChange = -drainRate;
            if (isHolding) {
                netFocusChange += grossRefillRate;
            }
            timer = Math.min(100, Math.max(0, timer + netFocusChange));
            
            const realTimePassed = 0.1;
            let goalTimeRefill = 0; 

            if (isHolding) {
                goalTimeRefill = realTimePassed * 10; 
            }
            const netTimeChange = realTimePassed - goalTimeRefill;

            timeElapsed = timeElapsed + netTimeChange;
            timeElapsed = Math.min(goalTimeSeconds, Math.max(0, timeElapsed));

            updateDisplay();

            if (timer <= 0) {
                showDistractedPopup();
                return;
            }

            if (timeElapsed >= goalTimeSeconds) {
                showGoalCompletedPopup();
            }
        }

        function updateDisplay() {
            if (!isGameActive) return;
            
            const remainingTime = Math.ceil(goalTimeSeconds - timeElapsed); 
            const hrs = Math.floor(remainingTime / 3600);
            const mins = Math.floor((remainingTime % 3600) / 60);
            const secs = Math.floor(remainingTime % 60);

            const timeString = `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            const percentage = Math.round(timer);

            focusLevelDisplay.innerHTML = `FOCUS: <span style="font-weight: 700;">${percentage}%</span>`;
            timeLeftDisplay.innerHTML = timeString;

            // Update visuals based on mode
            if (currentMode === 'line') {
                document.getElementById('lineFill').style.width = `${timer}%`;
            } else if (currentMode === 'square') {
                const size = (timer / 100) * 250; /* Based on 250px container */
                const inner = document.getElementById('squareInner');
                inner.style.width = `${size}px`;
                inner.style.height = `${size}px`;
            } else if (currentMode === 'circle') {
                if (!circleDrawLoop) {
                    circleDrawLoop = requestAnimationFrame(drawSmoothedCircle);
                }
            }
        }

        window.switchMode = function(mode) {
            currentMode = mode;
            
            if (circleDrawLoop) {
                cancelAnimationFrame(circleDrawLoop);
                circleDrawLoop = null;
            }

            document.getElementById('lineTimer').classList.remove('active-mode');
            document.getElementById('squareTimer').classList.remove('active-mode');
            document.getElementById('circleTimer').classList.remove('active-mode');
            
            document.getElementById(`${mode}Timer`).classList.add('active-mode');
            
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.mode === mode) {
                    btn.classList.add('active');
                }
            });
            
            setupCanvas();
            updateDisplay();

            if (mode === 'circle' && isGameActive) {
                 if (!circleDrawLoop) {
                    circleDrawLoop = requestAnimationFrame(drawSmoothedCircle);
                }
            } else if (mode === 'circle' && !isGameActive) {
                drawPie(100);
            }
        }
        
        function handleScroll(e) {
            e.preventDefault();

            let input = e.target;
            let currentValue = parseInt(input.value) || parseInt(input.min) || 0;
            let newValue;
            
            if (e.deltaY < 0) {
                newValue = currentValue + 1;
            } else if (e.deltaY > 0) {
                newValue = currentValue - 1;
            } else {
                return;
            }

            const max = parseInt(input.max) || 99;
            const min = parseInt(input.min) || 0;
            
            if (input.id === 'hrsInput') {
                newValue = Math.min(max, Math.max(min, newValue));
            } else {
                if (newValue > max) {
                    newValue = min; 
                } else if (newValue < min) {
                    newValue = max; 
                }
            }

            input.value = newValue.toString().padStart(2, '0');
            calculateGoalTime(); 
        }

        // --- Event Listeners for Input and Game Control ---

        function startHolding(e) {
            if (!isGameActive) return;

            if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'BUTTON') {
                e.preventDefault(); 
            }
            isHolding = true;
        }

        function stopHolding(e) {
            if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'BUTTON') {
                e.preventDefault();
            }
            isHolding = false;
        }

        document.addEventListener('mousedown', startHolding);
        document.addEventListener('mouseup', stopHolding);
        document.addEventListener('mouseleave', stopHolding);

        document.addEventListener('touchstart', startHolding, { passive: false });
        document.addEventListener('touchend', stopHolding, { passive: false });
        document.addEventListener('touchcancel', stopHolding, { passive: false });

        // --- Initial Application Setup ---
        
        window.addEventListener('resize', () => {
            setupCanvas();
            if (currentMode === 'circle' && !isGameActive) {
                drawPie(100); 
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            minInput.value = '01'; 
            hrsInput.value = '00';
            secInput.value = '00';
            
            document.querySelectorAll('.time-input').forEach(input => {
                input.addEventListener('wheel', handleScroll, { passive: false });
            });

            calculateGoalTime(); 
            setupCanvas();
            window.resetGameToReady(); 
        });
    </script>
</body>
</html>